<!DOCTYPE html>
<html>
<head>
    <title>LLM Interface</title>
    <!-- Add KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>

    <!-- Add Prism.js for code syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-night-owl.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.18/marked.min.js"></script>

    <script>
        function addCopyButtons() {
            // Add copy button to each code block
            document.querySelectorAll('pre').forEach(block => {
                if (block.querySelector('.copy-button')) return; // Skip if button already exists

                const button = document.createElement('button');
                button.className = 'copy-button';
                button.innerHTML = 'Copy';

                button.addEventListener('click', async () => {
                    const code = block.querySelector('code');
                    try {
                        await navigator.clipboard.writeText(code.textContent);
                        button.innerHTML = 'Copied!';
                        setTimeout(() => {
                            button.innerHTML = 'Copy';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                    }
                });

                block.style.position = 'relative';
                block.appendChild(button);
            });
        }

        marked.setOptions({
            highlight: function (code, lang) {
                if (Prism.languages[lang]) {
                    return Prism.highlight(code, Prism.languages[lang], lang);
                }
                return code;
            },
            langPrefix: 'language-'  // This is crucial for Prism.js to work
        });

        function formatTime(ms) {
            if (ms < 1000) return `${ms}ms`;
            const seconds = Math.floor(ms / 1000);
            const milliseconds = ms % 1000;
            return `${seconds}s ${milliseconds}ms`;
        }


        let thinkingStartTime = null;
        let currentThinkingContainer = null;
        let thinkingSectionCount = 0;
        let isInThinkingMode = false;
        let timerId = null;
        let finalThinkingTime = null;

        function processThinkingTags(text, aiContent) {
            const messageId = Date.now().toString();

            // Check if thinking section already exists for this AI message
            const existingThinking = aiContent.querySelector('.thinking-container');
            const existingAnswer = aiContent.querySelector('.answer-content');

            // If text contains think tags
            if (text.includes('<think>')) {
                if (!isInThinkingMode && !existingThinking) {
                    // Create a wrapper div for both thinking and answer
                    const wrapper = document.createElement('div');
                    wrapper.className = 'thinking-answer-wrapper';
                    wrapper.id = `wrapper-${messageId}`;

                    // Create thinking container for new thinking section
                    isInThinkingMode = true;
                    thinkingStartTime = thinkingStartTime || Date.now();
                    finalThinkingTime = null;

                    const thinkingContainer = document.createElement('div');
                    thinkingContainer.className = 'thinking-container';
                    thinkingContainer.id = `thinking-section-${messageId}`;
                    thinkingContainer.innerHTML = `
                <div class="thinking-header" onclick="toggleThinking('thinking-section-${messageId}')">
                    <span class="thinking-title">Thinking Process</span>
                    <span class="thinking-time" id="thinking-timer-${messageId}">Time: 0ms</span>
                    <span class="thinking-toggle">â–¼</span>
                </div>
                <div class="thinking-content"></div>
            `;

                    // Create answer container
                    const answerContainer = document.createElement('div');
                    answerContainer.className = 'answer-content';
                    answerContainer.id = `answer-section-${messageId}`;

                    // Add both containers to wrapper
                    wrapper.appendChild(thinkingContainer);
                    wrapper.appendChild(answerContainer);

                    // Add wrapper to aiContent
                    aiContent.appendChild(wrapper);

                    // Start timer
                    if (timerId) clearInterval(timerId);
                    timerId = setInterval(() => {
                        if (thinkingStartTime) {
                            const timeElement = document.getElementById(`thinking-timer-${messageId}`);
                            const elapsed = Date.now() - thinkingStartTime;
                            if (timeElement) {
                                timeElement.textContent = `Time: ${formatTime(elapsed)}`;
                            }
                        }
                    }, 100);
                }

                // Handle thinking content
                if (text.includes('</think>')) {
                    // Extract thinking content
                    const thinkRegex = /<think>([\s\S]*?)<\/think>/;
                    const match = text.match(thinkRegex);

                    if (match) {
                        // Update thinking content
                        const thinkingContent = match[1];
                        const thinkingContainer = aiContent.querySelector('.thinking-content');
                        if (thinkingContainer) {
                            thinkingContainer.innerHTML = marked.parse(thinkingContent);
                        }

                        // Update answer content with everything after </think>
                        const answerText = text.split('</think>')[1] || '';
                        const answerContainer = aiContent.querySelector('.answer-content');
                        if (answerContainer) {
                            answerContainer.innerHTML = marked.parse(answerText.trim());
                        }

                        // Stop thinking mode
                        isInThinkingMode = false;
                        finalThinkingTime = Date.now() - thinkingStartTime;
                        if (timerId) {
                            clearInterval(timerId);
                            timerId = null;
                        }
                    }
                } else {
                    // Still in thinking mode, update thinking content
                    const thinkRegex = /<think>([\s\S]*?)$/;
                    const match = text.match(thinkRegex);
                    if (match) {
                        const thinkingContent = match[1];
                        const container = aiContent.querySelector('.thinking-content');
                        if (container) {
                            container.innerHTML = marked.parse(thinkingContent);
                        }
                    }
                }
            } else {
                // No think tags, create or update answer section only
                if (!existingAnswer) {
                    const answerContainer = document.createElement('div');
                    answerContainer.className = 'answer-content';
                    answerContainer.id = `answer-section-${messageId}`;
                    aiContent.appendChild(answerContainer);
                }
                const answerContainer = aiContent.querySelector('.answer-content');
                if (answerContainer) {
                    answerContainer.innerHTML = marked.parse(text);
                }
            }
        }


        // Update the toggleThinking function to work with IDs
        function toggleThinking(thinkingSectionId) {
            const container = document.getElementById(thinkingSectionId);
            if (container) {
                container.classList.toggle('expanded');
            }
        }


        // Add these new functions to your existing JavaScript
        let currentConversationId = 'default';

        async function loadConversations() {
            const response = await fetch('/api/conversations');
            const conversations = await response.json();
            const select = document.getElementById('conversation-select');

            // If no conversations exist, create default one
            if (conversations.length === 0) {
                currentConversationId = 'default';
                select.innerHTML = `<option value="default">Default Chat</option>`;
            } else {
                select.innerHTML = conversations.map(id =>
                    `<option value="${id}" ${id === currentConversationId ? 'selected' : ''}>${id === 'default' ? 'Default Chat' : id}</option>`
                ).join('');
            }
        }

        async function loadCurrentConversation() {
            const response = await fetch(`/api/conversations/${currentConversationId}`);
            const messages = await response.json();
            const output = document.getElementById('formatted-output');

            output.innerHTML = messages.map(msg => {
                if (msg.role === 'user') {
                    return `
                <div class="chat-message user">
                    <div class="message-header">You</div>
                    <div class="message-content">${msg.content}</div>
                </div>`;
                } else {
                    const aiContent = document.createElement('div');
                    aiContent.className = 'chat-message assistant';
                    aiContent.innerHTML = `
                <div class="message-header">AI</div>
                <div class="message-content"></div>
            `;

                    const contentDiv = aiContent.querySelector('.message-content');
                    processThinkingTags(msg.content, contentDiv);

                    return aiContent.outerHTML;
                }
            }).join('');

            // Re-render any code blocks and LaTeX
            Prism.highlightAllUnder(output);
            renderMathInElement(output, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });
            addCopyButtons();
        }

        async function deleteCurrentConversation() {
            await fetch(`/api/conversations/${currentConversationId}`, {
                method: 'DELETE'
            });
            document.getElementById('formatted-output').innerHTML = '';
            await loadConversations();
            currentConversationId = 'default';
        }

        function newConversation() {
            // Generate unique conversation ID
            currentConversationId = Date.now().toString();

            // Clear output
            document.getElementById('formatted-output').innerHTML = '';

            // Add new conversation to select dropdown while preserving default
            const select = document.getElementById('conversation-select');
            const defaultOption = select.querySelector('option[value="default"]');

            const option = document.createElement('option');
            option.value = currentConversationId;
            option.text = currentConversationId;
            option.selected = true;

            if (defaultOption) {
                select.insertBefore(option, defaultOption.nextSibling);
            } else {
                select.add(option);
            }
        }

        async function sendPrompt() {
            const prompt = document.getElementById('prompt').value;
            const formattedOutput = document.getElementById('formatted-output');

            // Reset thinking state
            thinkingStartTime = null;
            currentThinkingContainer = null;
            isInThinkingMode = false;
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            }

            // Add user message immediately
            const userMessage = document.createElement('div');
            userMessage.className = 'chat-message user';
            userMessage.innerHTML = `
        <div class="message-header">You</div>
        <div class="message-content">${prompt}</div>
    `;
            formattedOutput.appendChild(userMessage);

            // Create AI message container
            const aiMessage = document.createElement('div');
            aiMessage.className = 'chat-message assistant';
            aiMessage.innerHTML = `
        <div class="message-header">AI</div>
        <div class="message-content"></div>
    `;
            formattedOutput.appendChild(aiMessage);

            const aiContent = aiMessage.querySelector('.message-content');
            let fullText = '';

            try {
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        conversation_id: currentConversationId
                    }),
                });

                if (!response.ok) throw new Error('Failed to fetch');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                // Remove any existing thinking and answer sections in this AI message
                const existingThinking = aiContent.querySelector('#thinking-section');
                const existingAnswer = aiContent.querySelector('#answer-section');
                if (existingThinking) existingThinking.remove();
                if (existingAnswer) existingAnswer.remove();

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    fullText += chunk;

                    // Process thinking tags and update content
                    processThinkingTags(fullText, aiContent);

                    // Re-render LaTeX and code highlighting
                    renderMathInElement(aiContent, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });
                    Prism.highlightAllUnder(aiContent);
                    addCopyButtons();

                    formattedOutput.scrollTop = formattedOutput.scrollHeight;
                }

                // Clear the input after successful submission
                document.getElementById('prompt').value = '';

            } catch (error) {
                console.error('Error:', error);
                aiContent.innerHTML = 'Error: Failed to generate response';
            }
        }


        window.onload = async () => {
            currentConversationId = 'default';
            await loadConversations();
            await loadCurrentConversation();
        };
    </script>

<body>
<div class="container">
    <div class="chat-controls">
        <select id="conversation-select" onchange="currentConversationId = this.value; loadCurrentConversation()">
        </select>
        <button class="new-chat" onclick="newConversation()">New Chat</button>
        <button class="delete-chat" onclick="deleteCurrentConversation()">Delete Chat</button>
    </div>

    <div id="formatted-output"></div>

    <textarea
            id="prompt"
            rows="5"
            placeholder="Enter your prompt here..."
    ></textarea>
    <button onclick="sendPrompt()">Send</button>
</div>
</body>
</html>
